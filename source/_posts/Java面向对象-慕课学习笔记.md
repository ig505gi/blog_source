---
title: Java面向对象-慕课学习笔记
categories:
  - CS网课笔记
tags:
  - Mooc
  - Java
  - OOP
  - Backend
abbrlink: 683
date: 2018-12-25 20:28:23
---

简介：慕课网课笔记，主要讲述Java的面向对象思想。用对象思考，用类来写作
课程地址：https://www.icourse163.org/course/ZJU-1001542001?tid=1003687002
作业仓库：https://github.com/ig505gi/JAVA-Course

# Part1 

## 1.类的定义
<!-- more -->
### 1.1 对象、函数
对象 = 属性 + 服务  
数据：属性，状态  
操作：函数  
操作是包含着数据的，把数据和对数据的操作放在一起，数据不对外面公开-->**封装**

### 1.2 this
在成员函数内部可以用this调用其他成员函数

### 1.3 成员变量&本地变量  
本地变量：生存期和作用域都在函数内部，定义在函数内部  
成员变量：生存期是对象的生成期，作用域是类中的成员函数，定义在类中

### 1.4 构造函数
构造函数与类名相同，没有返回类型，  
**重载**：可以有多个构造函数，根据参数不同调用不同的构造函数  
创建对象的时候，先调用构造函数，再初始化成员变量，再进入构造函数内部。

### 1.5 toString()
可以用于任何一个类中，使类的输出变成想要的结果

## 2 对象交互
### 2.1 访问属性
**private** 
私有成员是类的私有，不是对象的私有，可以在类中访问不同对象的私有变量。  
**friendly**
如果前面不加访问属性，就是friendly，在同一个包里可以使用  

### 2.2 类变量
**static** 静态变量，是类的变量，不是对象的变量，可以用”类.“去访问  
同样，函数前加 static，函数是类函数。  
**static函数只能调用static函数，只能访问static变量**

### 2.3  public&编译单元
public 类的定义加上public，该类一定在以该类命名的java文件中，如：   
`public class test{}` 一定在test.java中  
一个 \*\*.java是一个编译单元，里面只能有一个public类，并且和文件名相同

## 3 包
### 3.1
在一个包pac下面的的每个java文件一定有一行`package pac`  
包中类的调用方式：
![package](package.png)

## 4 对象容器
### 4.1 定义
`ArrayList<String> notes = new ArrayList<String>();`  
定义了一个存放String的ArrayList，ArrayList是一种范型类，就是一种容器  
容器的输出带着方括号

### 4.2 对象数组
对象数组的每一个元素都是对象的管理者，而非对象本身  
不像int数组，for-each循环的时候，不能对每个元素赋值，  
对象数组和对象容器都可以在for-each循环中，对对象的成员变量赋值。

### 4.3 set定义
`HashSet<String> notes = new HashSet<String>();`  
HashSet没有重复元素，乱序

### 4.4 Hash(类似python中字典)
`HashMap<Integer, String> hm = new Hashmap<Integer, String>();`  
需要用Integer，int的包裹类型，都是类的名字  
`hm.put(5, "five")` 用于往HashMap的对象中放元素  
重复key进行put，value会覆盖

## 5.继承与多态
### 5.1 定义
`class <子类名字> extends <父类名字> {}`  

### 5.2 父子类的关系
父类成员访问属性|在父类中的含义|在子类中的含义
-|-|-
public|对所有人开放|对所有人开放
protected|只有包内其它类、自己和子类可以访问|只有包内其它类、自己和子类可以访问
缺省|只有包内其它类可以访问|如果子类与父类在同一个包内：只有包内其它类可以访问，否则：相当于private，不能访问
private|只有自己可以访问|不能访问

在构造一个子类的对象时，父类的构造方法也是会被调用的，而且**父类的构造方法在子类的构造方法之前被调用**  
如果我们试图重新定义一个在父类中**已经存在**的成员变量，那么我们是在定义一个与父类的成员变量**完全无关**的变量，
在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们**同名但是互不影响**

### 5.3 super

`super()`在构造函数第一行执行，进入父类的构造函数，可以重载，调用不同的构造函数  
在子类中使用父类的函数，`super.parentsFunction()`  

### 5.4 多态变量和向上造型
JAVA中的变量都是多态变量，比如一个放水果的变量，可以放苹果，也可以重新放橘子，但是不能放打印机  
当把一个子类对象赋给父类变量时，发生了**向上造型*

例子：CD是Item的子类  
```
Item item = new Item();
CD cd = new CD();
item = cd；
CD cc = item; // 不对，编译不通过
CD cc = (CD)item; // 将Item类变量item当做CD类型去给cc变量赋值
```
用括号加类型放在变量前面的操作就叫做**造型**  
造型和（int）转换类型不同的！！一个是转换类型，一个是造型     
造型时，有可能出现**ClassCastException的错误**

### 5.5 绑定
当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。   
绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了，根据变量的**声明类型**决定；  
另一种是晚绑定，即动态绑定。动态绑定在根据变量的**动态类型**决定。    
Java缺省使用动态绑定。

### 5.6 override
**override 覆盖**  
通过父类的对象调用存在覆盖关系的函数时，会调用变量但是所管理的对象的类的函数  
利用IDE进行override时 在函数上会有`@Override`字段，  
如果该覆盖函数与父类的访问属性、返回类型、名称、参数表**有不同，就会报错**

## 6 抽象类
### 6.1 定义
`public class abstract shape{
    public abstract void draw(Graphcs g);
}`  
我们没有想过要真正实现一个shape类的对象, 但是要保存一些图形共有的属性。  
抽象类不能实例化  

子类中的函数**必须**全都覆盖抽象父类中的抽象函数，这叫做**实现**  
如果没有全部实现，子类也是抽象类

## 7. 接口
### 7.1 定义
声明 `public interface 接口名`  
接口是纯抽象类  
所有的成员函数都是抽象函数，所有的成员变量声明都是 `public static final`  
接口规定了长什么样，但不管里面是什么

### 7.2 类实现
如何**声明**  
`public class Fox extands Animal implements Cell {}`  
定义了一个 Fox类，继承自 Animal类， 实现了 Cell接口

### 7.3 接口变量(自己命名)
`Cell c = new Fox();`  
一个Cell接口的变量可以赋于任何一个实现了Cell接口的类  

### 7.4 使用规则
（1）接口是一种特殊的类，在使用上一样  
（2）类可以实现很多接口  
（3）接口可以继承接口，但不能继承类  
（4）接口不能实现接口  

## 8. 内部类
在一个A类的内部定义了一个B类，我就称这个B类为内部类  
内部类B**可以访问A类的成员函数、成员变量**，  
如果定义在A的外部，如果B想访问A类的成员，需要将A类实例化（**很麻烦**）

内部类也有可能**在函数内**(如下文中的匿名类)  
在函数内不能访问本地变量，只能访问有final修饰的本地变量

## 9. 匿名类
![匿名类](匿名类.png)  
这里定义的就是一个匿名类  

在new对象的时候给出的类的定义形成了匿名类，  
匿名类可以实现某接口，也可以继承自某个父类，  

*Swing框架的消息机制广泛运用匿名类*

## 10.final
inal关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：  

    1.用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值； 
    2.用来修饰方法参数，表示在变量的生存期中它的值不能被改变；
    3.修饰方法，表示该方法无法被重写；
    4.修饰类，表示该类无法被继承。

上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。


# Part2
## 1.一些设计原则
### 1.1. 消除代码复制

### 1.2. 封装
用封装来降低耦合

### 1.3. 可扩展性
用 框架+数据 提高扩展性  
方法：i）命令的解析是否可以脱离if-else  
     ii）定义一个Handler类来处理命令  
     iii）用Hash表来保存Handler和命令的关系

### 1.4. 接口的引入
设计程序时，先定义接口，再实现类  
任何需要在函数间传入传出的一定是接口而不是具体的类

## 2.设计思想
### 2.1. 控制反转
`[图丢失]`
Jbutton类想要实现按下去，调用step()的操作，但是我们不能在Jbutton类中再定义，是原本的框架。  
但是Jbutton类实现了ActionListener接口，并且有addActionListener函数。  
ActionListener接口中只有一个actionPerfomed函数， btnStep实例执行addActionListener函数后，就将actionPerfomed函数注册给了btnStep  
当btnStep被按下去的时候，就会执行外部override的actionPerfomed函数。  
### 2.2. MVC
View-Model-Control  
View 和 Control不直接有关系，通过Model(模型、数据)来连接

## 3.加载类
https://www.cnblogs.com/doit8791/p/5820037.html


ps：
* 在18年学习的，但是未发布在个人博客，2022年整理并同步到个人博客